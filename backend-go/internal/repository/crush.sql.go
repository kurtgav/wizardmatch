// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: crush.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createCrush = `-- name: CreateCrush :one
INSERT INTO crush_lists (
    user_id,
    campaign_id,
    crush_email,
    crush_name,
    is_matched,
    is_mutual,
    nudge_sent
) VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, user_id, campaign_id, crush_email, crush_name, is_matched, is_mutual, nudge_sent, created_at
`

type CreateCrushParams struct {
	UserID     uuid.UUID   `json:"user_id"`
	CampaignID uuid.UUID   `json:"campaign_id"`
	CrushEmail string      `json:"crush_email"`
	CrushName  pgtype.Text `json:"crush_name"`
	IsMatched  bool        `json:"is_matched"`
	IsMutual   bool        `json:"is_mutual"`
	NudgeSent  bool        `json:"nudge_sent"`
}

func (q *Queries) CreateCrush(ctx context.Context, arg CreateCrushParams) (CrushList, error) {
	row := q.db.QueryRow(ctx, createCrush,
		arg.UserID,
		arg.CampaignID,
		arg.CrushEmail,
		arg.CrushName,
		arg.IsMatched,
		arg.IsMutual,
		arg.NudgeSent,
	)
	var i CrushList
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CampaignID,
		&i.CrushEmail,
		&i.CrushName,
		&i.IsMatched,
		&i.IsMutual,
		&i.NudgeSent,
		&i.CreatedAt,
	)
	return i, err
}

const deleteCrushesForUserCampaign = `-- name: DeleteCrushesForUserCampaign :exec
DELETE FROM crush_lists WHERE user_id = $1 AND campaign_id = $2
`

type DeleteCrushesForUserCampaignParams struct {
	UserID     uuid.UUID `json:"user_id"`
	CampaignID uuid.UUID `json:"campaign_id"`
}

func (q *Queries) DeleteCrushesForUserCampaign(ctx context.Context, arg DeleteCrushesForUserCampaignParams) error {
	_, err := q.db.Exec(ctx, deleteCrushesForUserCampaign, arg.UserID, arg.CampaignID)
	return err
}

const listCrushesByEmailCampaign = `-- name: ListCrushesByEmailCampaign :many
SELECT id, user_id, campaign_id, crush_email, crush_name, is_matched, is_mutual, nudge_sent, created_at FROM crush_lists WHERE crush_email = $1 AND campaign_id = $2
`

type ListCrushesByEmailCampaignParams struct {
	CrushEmail string    `json:"crush_email"`
	CampaignID uuid.UUID `json:"campaign_id"`
}

func (q *Queries) ListCrushesByEmailCampaign(ctx context.Context, arg ListCrushesByEmailCampaignParams) ([]CrushList, error) {
	rows, err := q.db.Query(ctx, listCrushesByEmailCampaign, arg.CrushEmail, arg.CampaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CrushList{}
	for rows.Next() {
		var i CrushList
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CampaignID,
			&i.CrushEmail,
			&i.CrushName,
			&i.IsMatched,
			&i.IsMutual,
			&i.NudgeSent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCrushesForCampaign = `-- name: ListCrushesForCampaign :many
SELECT id, user_id, campaign_id, crush_email, crush_name, is_matched, is_mutual, nudge_sent, created_at FROM crush_lists WHERE campaign_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListCrushesForCampaign(ctx context.Context, campaignID uuid.UUID) ([]CrushList, error) {
	rows, err := q.db.Query(ctx, listCrushesForCampaign, campaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CrushList{}
	for rows.Next() {
		var i CrushList
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CampaignID,
			&i.CrushEmail,
			&i.CrushName,
			&i.IsMatched,
			&i.IsMutual,
			&i.NudgeSent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCrushesForUserCampaign = `-- name: ListCrushesForUserCampaign :many
SELECT id, user_id, campaign_id, crush_email, crush_name, is_matched, is_mutual, nudge_sent, created_at FROM crush_lists WHERE user_id = $1 AND campaign_id = $2 ORDER BY created_at DESC
`

type ListCrushesForUserCampaignParams struct {
	UserID     uuid.UUID `json:"user_id"`
	CampaignID uuid.UUID `json:"campaign_id"`
}

func (q *Queries) ListCrushesForUserCampaign(ctx context.Context, arg ListCrushesForUserCampaignParams) ([]CrushList, error) {
	rows, err := q.db.Query(ctx, listCrushesForUserCampaign, arg.UserID, arg.CampaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CrushList{}
	for rows.Next() {
		var i CrushList
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CampaignID,
			&i.CrushEmail,
			&i.CrushName,
			&i.IsMatched,
			&i.IsMutual,
			&i.NudgeSent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
