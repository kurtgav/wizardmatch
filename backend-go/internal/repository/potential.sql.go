// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: potential.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const findOrCreateMatchForUsers = `-- name: FindOrCreateMatchForUsers :one
INSERT INTO matches (user1_id, user2_id, compatibility_score, match_tier, shared_interests)
VALUES (
    LEAST($1, $2),
    GREATEST($1, $2),
    0,
    'potential',
    '{}'::jsonb
)
ON CONFLICT (user1_id, user2_id) DO UPDATE SET updated_at = NOW()
RETURNING id, campaign_id, user1_id, user2_id, compatibility_score, match_tier, shared_interests, rank_for_user1, rank_for_user2, is_revealed, is_mutual_interest, is_mutual_crush, messaging_unlocked, created_at, revealed_at, updated_at
`

type FindOrCreateMatchForUsersParams struct {
	Column1 interface{} `json:"column_1"`
	Column2 interface{} `json:"column_2"`
}

func (q *Queries) FindOrCreateMatchForUsers(ctx context.Context, arg FindOrCreateMatchForUsersParams) (Match, error) {
	row := q.db.QueryRow(ctx, findOrCreateMatchForUsers, arg.Column1, arg.Column2)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.User1ID,
		&i.User2ID,
		&i.CompatibilityScore,
		&i.MatchTier,
		&i.SharedInterests,
		&i.RankForUser1,
		&i.RankForUser2,
		&i.IsRevealed,
		&i.IsMutualInterest,
		&i.IsMutualCrush,
		&i.MessagingUnlocked,
		&i.CreatedAt,
		&i.RevealedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMatchByUsers = `-- name: GetMatchByUsers :one
SELECT id, campaign_id, user1_id, user2_id, compatibility_score, match_tier, shared_interests, rank_for_user1, rank_for_user2, is_revealed, is_mutual_interest, is_mutual_crush, messaging_unlocked, created_at, revealed_at, updated_at FROM matches
WHERE (user1_id = $1 AND user2_id = $2) OR (user1_id = $2 AND user2_id = $1)
LIMIT 1
`

type GetMatchByUsersParams struct {
	User1ID uuid.UUID `json:"user1_id"`
	User2ID uuid.UUID `json:"user2_id"`
}

func (q *Queries) GetMatchByUsers(ctx context.Context, arg GetMatchByUsersParams) (Match, error) {
	row := q.db.QueryRow(ctx, getMatchByUsers, arg.User1ID, arg.User2ID)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.User1ID,
		&i.User2ID,
		&i.CompatibilityScore,
		&i.MatchTier,
		&i.SharedInterests,
		&i.RankForUser1,
		&i.RankForUser2,
		&i.IsRevealed,
		&i.IsMutualInterest,
		&i.IsMutualCrush,
		&i.MessagingUnlocked,
		&i.CreatedAt,
		&i.RevealedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPotentialMatches = `-- name: ListPotentialMatches :many
SELECT u.id, u.email, u.first_name, u.last_name, u.program, u.year_level, u.gender, u.seeking_gender, u.profile_photo_url, u.bio
FROM users u
WHERE u.survey_completed = TRUE
  AND u.is_active = TRUE
  AND u.id != $1
  AND u.id NOT IN (
    SELECT CASE WHEN m.user1_id = $1 THEN m.user2_id ELSE m.user1_id END
    FROM matches m
    WHERE m.user1_id = $1 OR m.user2_id = $1
  )
  AND u.id NOT IN (
    SELECT i.user_id FROM interactions i
    JOIN matches m ON m.id = i.match_id
    WHERE (m.user1_id = $1 OR m.user2_id = $1)
      AND i.interaction_type IN ('pass', 'interest', 'not_interested')
  )
ORDER BY RANDOM()
LIMIT 20
`

type ListPotentialMatchesRow struct {
	ID              uuid.UUID   `json:"id"`
	Email           string      `json:"email"`
	FirstName       string      `json:"first_name"`
	LastName        string      `json:"last_name"`
	Program         pgtype.Text `json:"program"`
	YearLevel       pgtype.Int4 `json:"year_level"`
	Gender          pgtype.Text `json:"gender"`
	SeekingGender   pgtype.Text `json:"seeking_gender"`
	ProfilePhotoUrl pgtype.Text `json:"profile_photo_url"`
	Bio             pgtype.Text `json:"bio"`
}

func (q *Queries) ListPotentialMatches(ctx context.Context, id uuid.UUID) ([]ListPotentialMatchesRow, error) {
	rows, err := q.db.Query(ctx, listPotentialMatches, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPotentialMatchesRow{}
	for rows.Next() {
		var i ListPotentialMatchesRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.Program,
			&i.YearLevel,
			&i.Gender,
			&i.SeekingGender,
			&i.ProfilePhotoUrl,
			&i.Bio,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordUserInteraction = `-- name: RecordUserInteraction :one
INSERT INTO interactions (match_id, user_id, interaction_type, metadata)
VALUES ($1, $2, $3, $4)
RETURNING id, match_id, user_id, interaction_type, metadata, created_at
`

type RecordUserInteractionParams struct {
	MatchID         uuid.UUID `json:"match_id"`
	UserID          uuid.UUID `json:"user_id"`
	InteractionType string    `json:"interaction_type"`
	Metadata        []byte    `json:"metadata"`
}

func (q *Queries) RecordUserInteraction(ctx context.Context, arg RecordUserInteractionParams) (Interaction, error) {
	row := q.db.QueryRow(ctx, recordUserInteraction,
		arg.MatchID,
		arg.UserID,
		arg.InteractionType,
		arg.Metadata,
	)
	var i Interaction
	err := row.Scan(
		&i.ID,
		&i.MatchID,
		&i.UserID,
		&i.InteractionType,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}
