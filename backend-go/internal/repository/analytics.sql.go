// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: analytics.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const averageCompatibilityScore = `-- name: AverageCompatibilityScore :one
SELECT COALESCE(AVG(compatibility_score), 0)::float8 FROM matches
`

func (q *Queries) AverageCompatibilityScore(ctx context.Context) (float64, error) {
	row := q.db.QueryRow(ctx, averageCompatibilityScore)
	var column_1 float64
	err := row.Scan(&column_1)
	return column_1, err
}

const averageCompatibilityScoreByCampaign = `-- name: AverageCompatibilityScoreByCampaign :one
SELECT COALESCE(AVG(compatibility_score), 0)::float8 FROM matches WHERE campaign_id = $1
`

func (q *Queries) AverageCompatibilityScoreByCampaign(ctx context.Context, campaignID pgtype.UUID) (float64, error) {
	row := q.db.QueryRow(ctx, averageCompatibilityScoreByCampaign, campaignID)
	var column_1 float64
	err := row.Scan(&column_1)
	return column_1, err
}

const countActiveUsers = `-- name: CountActiveUsers :one
SELECT COUNT(*) FROM users WHERE is_active = TRUE
`

func (q *Queries) CountActiveUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCompletedSurveys = `-- name: CountCompletedSurveys :one
SELECT COUNT(*) FROM users WHERE is_active = TRUE AND survey_completed = TRUE
`

func (q *Queries) CountCompletedSurveys(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countCompletedSurveys)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMatches = `-- name: CountMatches :one
SELECT COUNT(*) FROM matches
`

func (q *Queries) CountMatches(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countMatches)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMatchesByCampaign = `-- name: CountMatchesByCampaign :one
SELECT COUNT(*) FROM matches WHERE campaign_id = $1
`

func (q *Queries) CountMatchesByCampaign(ctx context.Context, campaignID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countMatchesByCampaign, campaignID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMutualMatches = `-- name: CountMutualMatches :one
SELECT COUNT(*) FROM matches WHERE is_mutual_interest = TRUE
`

func (q *Queries) CountMutualMatches(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countMutualMatches)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMutualMatchesByCampaign = `-- name: CountMutualMatchesByCampaign :one
SELECT COUNT(*) FROM matches WHERE is_mutual_interest = TRUE AND campaign_id = $1
`

func (q *Queries) CountMutualMatchesByCampaign(ctx context.Context, campaignID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countMutualMatchesByCampaign, campaignID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRevealedMatches = `-- name: CountRevealedMatches :one
SELECT COUNT(*) FROM matches WHERE is_revealed = TRUE
`

func (q *Queries) CountRevealedMatches(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countRevealedMatches)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRevealedMatchesByCampaign = `-- name: CountRevealedMatchesByCampaign :one
SELECT COUNT(*) FROM matches WHERE is_revealed = TRUE AND campaign_id = $1
`

func (q *Queries) CountRevealedMatchesByCampaign(ctx context.Context, campaignID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countRevealedMatchesByCampaign, campaignID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const matchesByTier = `-- name: MatchesByTier :many
SELECT match_tier, COUNT(*) AS count
FROM matches
GROUP BY match_tier
`

type MatchesByTierRow struct {
	MatchTier pgtype.Text `json:"match_tier"`
	Count     int64       `json:"count"`
}

func (q *Queries) MatchesByTier(ctx context.Context) ([]MatchesByTierRow, error) {
	rows, err := q.db.Query(ctx, matchesByTier)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MatchesByTierRow{}
	for rows.Next() {
		var i MatchesByTierRow
		if err := rows.Scan(&i.MatchTier, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const matchesByTierByCampaign = `-- name: MatchesByTierByCampaign :many
SELECT match_tier, COUNT(*) AS count
FROM matches
WHERE campaign_id = $1
GROUP BY match_tier
`

type MatchesByTierByCampaignRow struct {
	MatchTier pgtype.Text `json:"match_tier"`
	Count     int64       `json:"count"`
}

func (q *Queries) MatchesByTierByCampaign(ctx context.Context, campaignID pgtype.UUID) ([]MatchesByTierByCampaignRow, error) {
	rows, err := q.db.Query(ctx, matchesByTierByCampaign, campaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MatchesByTierByCampaignRow{}
	for rows.Next() {
		var i MatchesByTierByCampaignRow
		if err := rows.Scan(&i.MatchTier, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const programsWithCompletion = `-- name: ProgramsWithCompletion :many
SELECT program,
       COUNT(*) AS total,
       SUM(CASE WHEN survey_completed = TRUE THEN 1 ELSE 0 END) AS completed
FROM users
WHERE is_active = TRUE AND program IS NOT NULL
GROUP BY program
ORDER BY total DESC
`

type ProgramsWithCompletionRow struct {
	Program   pgtype.Text `json:"program"`
	Total     int64       `json:"total"`
	Completed int64       `json:"completed"`
}

func (q *Queries) ProgramsWithCompletion(ctx context.Context) ([]ProgramsWithCompletionRow, error) {
	rows, err := q.db.Query(ctx, programsWithCompletion)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProgramsWithCompletionRow{}
	for rows.Next() {
		var i ProgramsWithCompletionRow
		if err := rows.Scan(&i.Program, &i.Total, &i.Completed); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const programsWithCompletionByCampaign = `-- name: ProgramsWithCompletionByCampaign :many
SELECT u.program,
       COUNT(DISTINCT u.id) AS total,
       SUM(CASE WHEN u.survey_completed = TRUE THEN 1 ELSE 0 END) AS completed
FROM users u
JOIN survey_responses sr ON sr.user_id = u.id
WHERE sr.campaign_id = $1 AND u.program IS NOT NULL
GROUP BY u.program
ORDER BY total DESC
`

type ProgramsWithCompletionByCampaignRow struct {
	Program   pgtype.Text `json:"program"`
	Total     int64       `json:"total"`
	Completed int64       `json:"completed"`
}

func (q *Queries) ProgramsWithCompletionByCampaign(ctx context.Context, campaignID pgtype.UUID) ([]ProgramsWithCompletionByCampaignRow, error) {
	rows, err := q.db.Query(ctx, programsWithCompletionByCampaign, campaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProgramsWithCompletionByCampaignRow{}
	for rows.Next() {
		var i ProgramsWithCompletionByCampaignRow
		if err := rows.Scan(&i.Program, &i.Total, &i.Completed); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const topPrograms = `-- name: TopPrograms :many
SELECT program, COUNT(*) AS count
FROM users
WHERE survey_completed = TRUE AND program IS NOT NULL
GROUP BY program
ORDER BY count DESC
LIMIT $1
`

type TopProgramsRow struct {
	Program pgtype.Text `json:"program"`
	Count   int64       `json:"count"`
}

func (q *Queries) TopPrograms(ctx context.Context, limit int32) ([]TopProgramsRow, error) {
	rows, err := q.db.Query(ctx, topPrograms, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TopProgramsRow{}
	for rows.Next() {
		var i TopProgramsRow
		if err := rows.Scan(&i.Program, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const topProgramsByCampaign = `-- name: TopProgramsByCampaign :many
SELECT u.program, COUNT(*) AS count
FROM users u
JOIN survey_responses sr ON sr.user_id = u.id
WHERE sr.campaign_id = $1 AND u.survey_completed = TRUE AND u.program IS NOT NULL
GROUP BY u.program
ORDER BY count DESC
LIMIT $2
`

type TopProgramsByCampaignParams struct {
	CampaignID pgtype.UUID `json:"campaign_id"`
	Limit      int32       `json:"limit"`
}

type TopProgramsByCampaignRow struct {
	Program pgtype.Text `json:"program"`
	Count   int64       `json:"count"`
}

func (q *Queries) TopProgramsByCampaign(ctx context.Context, arg TopProgramsByCampaignParams) ([]TopProgramsByCampaignRow, error) {
	rows, err := q.db.Query(ctx, topProgramsByCampaign, arg.CampaignID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TopProgramsByCampaignRow{}
	for rows.Next() {
		var i TopProgramsByCampaignRow
		if err := rows.Scan(&i.Program, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const yearLevelsWithCompletion = `-- name: YearLevelsWithCompletion :many
SELECT year_level,
       COUNT(*) AS total,
       SUM(CASE WHEN survey_completed = TRUE THEN 1 ELSE 0 END) AS completed
FROM users
WHERE is_active = TRUE AND year_level IS NOT NULL
GROUP BY year_level
ORDER BY year_level ASC
`

type YearLevelsWithCompletionRow struct {
	YearLevel pgtype.Int4 `json:"year_level"`
	Total     int64       `json:"total"`
	Completed int64       `json:"completed"`
}

func (q *Queries) YearLevelsWithCompletion(ctx context.Context) ([]YearLevelsWithCompletionRow, error) {
	rows, err := q.db.Query(ctx, yearLevelsWithCompletion)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []YearLevelsWithCompletionRow{}
	for rows.Next() {
		var i YearLevelsWithCompletionRow
		if err := rows.Scan(&i.YearLevel, &i.Total, &i.Completed); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const yearLevelsWithCompletionByCampaign = `-- name: YearLevelsWithCompletionByCampaign :many
SELECT u.year_level,
       COUNT(DISTINCT u.id) AS total,
       SUM(CASE WHEN u.survey_completed = TRUE THEN 1 ELSE 0 END) AS completed
FROM users u
JOIN survey_responses sr ON sr.user_id = u.id
WHERE sr.campaign_id = $1 AND u.year_level IS NOT NULL
GROUP BY u.year_level
ORDER BY u.year_level ASC
`

type YearLevelsWithCompletionByCampaignRow struct {
	YearLevel pgtype.Int4 `json:"year_level"`
	Total     int64       `json:"total"`
	Completed int64       `json:"completed"`
}

func (q *Queries) YearLevelsWithCompletionByCampaign(ctx context.Context, campaignID pgtype.UUID) ([]YearLevelsWithCompletionByCampaignRow, error) {
	rows, err := q.db.Query(ctx, yearLevelsWithCompletionByCampaign, campaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []YearLevelsWithCompletionByCampaignRow{}
	for rows.Next() {
		var i YearLevelsWithCompletionByCampaignRow
		if err := rows.Scan(&i.YearLevel, &i.Total, &i.Completed); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
