// Prisma Schema for Map√∫a MCL Perfect Match - Wizard Match Edition

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Campaign Model - Manages Valentine's 2026 campaign
model Campaign {
  id                      String    @id @default(uuid())
  name                    String    // "Valentine's 2026 Matching"
  surveyOpenDate          DateTime  @map("survey_open_date") // Feb 5
  surveyCloseDate         DateTime  @map("survey_close_date") // Feb 10, 11:59 PM
  profileUpdateStartDate  DateTime  @map("profile_update_start_date") // Feb 11
  profileUpdateEndDate    DateTime  @map("profile_update_end_date") // Feb 13
  resultsReleaseDate      DateTime  @map("results_release_date") // Feb 14
  isActive                Boolean   @default(true) @map("is_active")
  totalParticipants       Int       @default(0) @map("total_participants")
  totalMatchesGenerated   Int       @default(0) @map("total_matches_generated")
  algorithmVersion        String?   @map("algorithm_version")
  config                  Json?     // Stores weights and algorithm params
  createdAt               DateTime  @default(now()) @map("created_at")

  // Relations
  questions               Question[]
  surveyResponses         SurveyResponse[]
  crushLists              CrushList[]
  matches                 Match[]

  @@map("campaigns")
}

// User Model - Enhanced with seeking_gender and contact preferences
model User {
  id                String    @id @default(uuid())
  email             String    @unique
  studentId         String?   @unique @map("student_id") // Made optional for Google auth
  firstName         String    @map("first_name")
  lastName          String    @map("last_name")
  program           String?
  yearLevel         Int?      @map("year_level")
  gender            String?
  seekingGender     String?   @map("seeking_gender") // "Male", "Female", "Non-binary", "Any"
  dateOfBirth       DateTime? @map("date_of_birth")
  profilePhotoUrl   String?   @map("profile_photo_url")
  bio               String?   @db.Text
  instagramHandle   String?   @map("instagram_handle")
  facebookProfile   String?   @map("facebook_profile")
  phoneNumber       String?   @map("phone_number")
  contactPreference String?   @map("contact_preference") // "Instagram", "Phone", "Email"
  profileVisibility String    @default("Matches Only") @map("profile_visibility") // "Public", "Matches Only", "Private"

  // Preferences stored as JSON
  preferences       Json?

  // Timestamps
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")
  lastLogin         DateTime? @map("last_login")

  // Status
  isActive          Boolean   @default(true) @map("is_active")
  surveyCompleted   Boolean   @default(false) @map("survey_completed")

  // Relations
  surveyResponses   SurveyResponse[]
  matchesAsUser1    Match[]   @relation("User1Matches")
  matchesAsUser2    Match[]   @relation("User2Matches")
  interactions      Interaction[]
  adminSettings     AdminSetting[]
  sentMessages      Message[] @relation("SentMessages")
  receivedMessages  Message[] @relation("ReceivedMessages")
  crushLists        CrushList[]

  @@map("users")
}

// Question Model - Linked to campaigns
model Question {
  id            String   @id @default(uuid())
  campaignId    String?  @map("campaign_id")
  category      String
  questionText  String   @map("question_text")
  questionType  String   @map("question_type") // multiple_choice, scale, text, ranking
  options       Json?    // For multiple choice options
  weight        Decimal  @default(1.00) @db.Decimal(3, 2)
  isActive      Boolean  @default(true) @map("is_active")
  orderIndex    Int      @map("order_index")
  createdAt     DateTime @default(now()) @map("created_at")

  // Relations
  campaign      Campaign? @relation(fields: [campaignId], references: [id], onDelete: SetNull)
  responses     SurveyResponse[]

  @@map("questions")
}

// Survey Response Model - Linked to campaigns
model SurveyResponse {
  id          String   @id @default(uuid())
  userId      String   @map("user_id")
  campaignId  String?  @map("campaign_id")
  questionId  String   @map("question_id")
  answerText  String?  @map("answer_text") @db.Text
  answerValue Int?     @map("answer_value")
  answerType  String   @map("answer_type") // multiple_choice, scale, text, ranking
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  campaign    Campaign? @relation(fields: [campaignId], references: [id], onDelete: SetNull)
  question    Question @relation(fields: [questionId], references: [id])

  @@unique([userId, questionId])
  @@map("survey_responses")
}

// Match Model - Enhanced with campaign link and messaging
model Match {
  id                   String    @id @default(uuid())
  campaignId           String?   @map("campaign_id")
  user1Id              String    @map("user1_id")
  user2Id              String    @map("user2_id")
  compatibilityScore   Decimal   @map("compatibility_score") @db.Decimal(5, 2)
  matchTier            String?   @map("match_tier") // perfect, excellent, great, good
  sharedInterests      Json?     @map("shared_interests")
  rankForUser1         Int?      @map("rank_for_user1") // 1-7 ranking
  rankForUser2         Int?      @map("rank_for_user2") // 1-7 ranking

  // Match details
  isRevealed           Boolean   @default(false) @map("is_revealed")
  isMutualInterest     Boolean   @default(false) @map("is_mutual_interest")
  isMutualCrush        Boolean   @default(false) @map("is_mutual_crush") // NEW: For crush list matching
  messagingUnlocked    Boolean   @default(false) @map("messaging_unlocked") // NEW: For Feb 11-13
  createdAt            DateTime  @default(now()) @map("created_at")
  revealedAt           DateTime? @map("revealed_at")

  // Relations
  campaign             Campaign? @relation(fields: [campaignId], references: [id], onDelete: SetNull)
  user1                User      @relation("User1Matches", fields: [user1Id], references: [id], onDelete: Cascade)
  user2                User      @relation("User2Matches", fields: [user2Id], references: [id], onDelete: Cascade)
  interactions         Interaction[]
  messages             Message[]

  @@unique([user1Id, user2Id])
  @@index([campaignId])
  @@map("matches")
}

// Interaction Model
model Interaction {
  id              String   @id @default(uuid())
  matchId         String   @map("match_id")
  userId          String   @map("user_id")
  interactionType String   @map("interaction_type") // view, message, report, block, interest, not_interested
  metadata        Json?
  createdAt       DateTime @default(now()) @map("created_at")

  // Relations
  match           Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("interactions")
}

// Message Model - NEW: For Feb 11-13 early messaging
model Message {
  id         String   @id @default(uuid())
  matchId    String   @map("match_id")
  senderId   String   @map("sender_id")
  recipientId String  @map("recipient_id")
  content    String   @db.Text
  isRead     Boolean  @default(false) @map("is_read")
  sentAt     DateTime @default(now()) @map("sent_at")
  readAt     DateTime? @map("read_at")

  // Relations
  match      Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  sender     User     @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  recipient  User     @relation("ReceivedMessages", fields: [recipientId], references: [id], onDelete: Cascade)

  @@index([matchId])
  @@index([senderId])
  @@index([recipientId])
  @@index([recipientId, isRead])
  @@map("messages")
}

// Crush List Model - NEW: For crush list feature
model CrushList {
  id         String   @id @default(uuid())
  userId     String   @map("user_id")
  campaignId String   @map("campaign_id")
  crushEmail String   @map("crush_email")
  crushName  String?  @map("crush_name")
  isMatched  Boolean  @default(false) @map("is_matched")
  isMutual   Boolean  @default(false) @map("is_mutual")
  nudgeSent  Boolean  @default(false) @map("nudge_sent")
  createdAt  DateTime @default(now()) @map("created_at")

  // Relations
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  campaign   Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)

  @@unique([userId, crushEmail, campaignId])
  @@index([crushEmail])
  @@map("crush_lists")
}

// Admin Settings Model
model AdminSetting {
  id           String   @id @default(uuid())
  settingKey   String   @unique @map("setting_key")
  settingValue Json     @map("setting_value")
  updatedAt    DateTime @updatedAt @map("updated_at")
  updatedBy    String?  @map("updated_by")

  // Relations
  user         User?    @relation(fields: [updatedBy], references: [id])

  @@map("admin_settings")
}

// Testimonial Model
model Testimonial {
  id          String   @id @default(uuid())
  name        String
  email       String?
  heading     String
  content     String   @db.Text
  isApproved  Boolean  @default(false) @map("is_approved")
  isPublished Boolean  @default(false) @map("is_published")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  @@map("testimonials")
}
